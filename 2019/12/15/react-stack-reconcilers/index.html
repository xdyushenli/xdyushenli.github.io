<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="1. 实现说明这部分是一个对于如何实现 Stack Reconciler 的总结。这部分比较晦涩难懂, 并且要求对 React 公共 API 以及核心代码、渲染器和 Reconcilers 是如何划分的有一定了解。如果对 React 源码不是很熟悉, 请先阅读源码概述。这部分同样要求你明白在 React 中组件、实例和元素的区别。Stack Reconciler 在 React 15 以及更早的版">
<meta property="og:type" content="article">
<meta property="og:title" content="0react-stack-reconsilers">
<meta property="og:url" content="http://yoursite.com/2019/12/15/react-stack-reconcilers/index.html">
<meta property="og:site_name" content="敝舍">
<meta property="og:description" content="1. 实现说明这部分是一个对于如何实现 Stack Reconciler 的总结。这部分比较晦涩难懂, 并且要求对 React 公共 API 以及核心代码、渲染器和 Reconcilers 是如何划分的有一定了解。如果对 React 源码不是很熟悉, 请先阅读源码概述。这部分同样要求你明白在 React 中组件、实例和元素的区别。Stack Reconciler 在 React 15 以及更早的版">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/react-stack-reconcilers/01.png">
<meta property="og:updated_time" content="2020-01-03T06:10:47.372Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="0react-stack-reconsilers">
<meta name="twitter:description" content="1. 实现说明这部分是一个对于如何实现 Stack Reconciler 的总结。这部分比较晦涩难懂, 并且要求对 React 公共 API 以及核心代码、渲染器和 Reconcilers 是如何划分的有一定了解。如果对 React 源码不是很熟悉, 请先阅读源码概述。这部分同样要求你明白在 React 中组件、实例和元素的区别。Stack Reconciler 在 React 15 以及更早的版">
<meta name="twitter:image" content="http://yoursite.com/images/react-stack-reconcilers/01.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/12/15/react-stack-reconcilers/">





  <title>0react-stack-reconsilers | 敝舍</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">敝舍</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/15/react-stack-reconcilers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mett Li">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="敝舍">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">0react-stack-reconsilers</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-15T16:27:23+08:00">
                2019-12-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="实现说明">1. 实现说明</h1><p>这部分是一个对于如何实现 Stack Reconciler 的总结。<br>这部分比较晦涩难懂, 并且要求对 React 公共 API 以及核心代码、渲染器和 Reconcilers 是如何划分的有一定了解。如果对 React 源码不是很熟悉, 请先阅读源码概述。<br>这部分同样要求你明白在 React 中组件、实例和元素的区别。<br>Stack Reconciler 在 React 15 以及更早的版本中使用。源码位置位于<code>src/rederers/shared/stack/reconciler</code>。</p>
<h2 id="从零开始构建-React">1.1. 从零开始构建 React</h2><p>Paul O’Shannessy 关于<a href="https://www.youtube.com/watch?v=_MAD4Oly9yg" target="_blank" rel="noopener">如何从零开始构建 React</a> 的演讲大大启发了该文章。<br>本文以及他的演讲都是对源码的简化概述, 因此要想更好地了解 React 其中的原委, 最好对二者都进行一定了解。</p>
<h2 id="概述">1.2. 概述</h2><p>reconciler 本身并没有公共 API。像 React DOM 和 React Native 这样的渲染器使用 reconciler 高效更新使用者编写的 React 组件, 进而更新用户页面。</p>
<h2 id="递归挂载">1.3. 递归挂载</h2><p>假设我们需要首次将一个组件挂载：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootEl);</span></span><br></pre></td></tr></table></figure>

<p>React DOM 会把 <code>&lt;App /&gt;</code> 传递给 reconsiler。记住 <code>&lt;App /&gt;</code> 是一个 React 元素, 描述的是应该去渲染什么。你可以认为它本质上是一个普通的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">// &#123; type: App, props: &#123;&#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>reconciler 会对 <code>App</code> 进行检测, 以确定它是一个函数还是一个类。<br>如果 <code>App</code> 是一个函数, 那么 reconciler 会调用 <code>App(props)</code> 来获取需要呈现的元素。<br>如果 <code>App</code> 是一个组件, 那么 reconciler 会以 <code>new App(props)</code> 的形式来创建一个 <code>App</code> 实例, 并调用 <code>componentWillMount()</code> 这一个生命周期方法, 然后再调用 <code>render()</code> 方法以获取需要呈现的元素。<br>不管通过哪种方式, reconciler 都会了解到 <code>App</code> 应该最终呈现出的元素。<br>整个过程是递归的。<code>App</code> 可以渲染为 <code>&lt;Greeting /&gt;</code>, <code>Greeting</code> 可以渲染为一个 <code>&lt;Button /&gt;</code>, 以此类推。reconciler 在呈现某个组件时会递归地“深入挖掘”用户自定义的组件, 直到整个组件被渲染出来为止。<br>你可以通过如下伪代码来了解这一进程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isClass</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// React.Component 的子类具有此标志</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="built_in">Boolean</span>(type.prototype) &amp;&amp;</span><br><span class="line">    <span class="built_in">Boolean</span>(type.prototype.isReactComponent)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数接收一个React元素 (例如&lt;App /&gt;) , 返回表示需要挂载的 DOM 树或 Native 节点树。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> type = element.type;</span><br><span class="line">  <span class="keyword">var</span> props = element.props;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据元素的 type 判断应该如何获取渲染后的元素：要么直接调用 type 对应的函数并把 props 传进去; 要么创建组件实例, 并调用 render()</span></span><br><span class="line">  <span class="keyword">var</span> renderedElement;</span><br><span class="line">  <span class="keyword">if</span> (isClass(type)) &#123;</span><br><span class="line">    <span class="comment">// 类组件</span></span><br><span class="line">    <span class="keyword">var</span> publicInstance = <span class="keyword">new</span> type(props);</span><br><span class="line">    <span class="comment">// 设置 props</span></span><br><span class="line">    publicInstance.props = props;</span><br><span class="line">    <span class="comment">// 调用生命周期函数</span></span><br><span class="line">    <span class="keyword">if</span> (publicInstance.componentWillMount) &#123;</span><br><span class="line">      publicInstance.componentWillMount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过调用 render() 获取渲染的元素</span></span><br><span class="line">    renderedElement = publicInstance.render();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 函数组件</span></span><br><span class="line">    renderedElement = type(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此过程是递归的，因为组件可能返回具有其他组件类型的元素</span></span><br><span class="line">  <span class="keyword">return</span> mount(renderedElement);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: 这段代码并不完整且会无限递归！</span></span><br><span class="line">  <span class="comment">// 这段代码只处理像 &lt;App /&gt; 和 &lt;Button /&gt;一样的组件元素, 并不会处理像 &lt;div /&gt; 和 &lt;p /&gt; 这样的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rootEl = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>);</span><br><span class="line"><span class="keyword">var</span> node = mount(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">rootEl.appendChild(node);</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这段伪代码只是为了说明思路, 它真正的实现并不相似。由于没有设置停止递归的条件, 这段代码还会造成堆栈溢出。</p>
</blockquote>
<p>让我们回顾一下上面实例中的一些关键思想：</p>
<ul>
<li>React 元素是表示元素类型 (例如 App) 以及 props 的普通对象。</li>
<li>用户定义的组件 (例如 App) 可以是类或函数, 但它们都被渲染为元素。</li>
<li><code>挂载</code>是一个递归过程, 它通过给定的顶级 React 元素 (例如 <app>) 创建 DOM 或 Native 节点树。</app></li>
</ul>
<h1 id="挂载宿主元素-host-elements">2. 挂载宿主元素 (host elements)</h1><p>宿主元素就是由不同平台自定义的元素, 比如 DOM 中的 <div>。对于宿主元素来说, 用户不需要编写其定义。<br>除了用户定义的复合组件之外, React 元素还可能代表平台相关的组件。例如, Button 的 render() 或许会返回一个 <div>。<br>如果元素的 type 属性是一个字符串, 那么 React 会将其作为与宿主元素进行处理。</div></div></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">// &#123; type: 'div', props: &#123;&#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>当 reconciler 处理到宿主元素时, 它会使特定渲染器负责进行挂载。例如 React DOM 将创建一个 DOM 节点。<br>如果宿主元素包含子元素, 那么 reconciler 将会使用和上面一样的算法递归地进行挂载。子元素可以包含宿主元素 (比如 <div><hr></div>) 或复合组件 (如 <div><button></button></div>) , 也可以同时包含两者。<br>子组件产生的 DOM 节点将被添加到父 DOM 节点中, 然后将递归地组装完整的 DOM 结构。</p>
<blockquote>
<p>reconciler 与 DOM 平台并不绑定。挂载的结果取决于使用的渲染器。</p>
</blockquote>
<p>我们将上面的代码扩展一下, 以便其支持宿主元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isClass</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// React.Component 的子类拥有此标志</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="built_in">Boolean</span>(type.prototype) &amp;&amp;</span><br><span class="line">    <span class="built_in">Boolean</span>(type.prototype.isReactComponent)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数只处理组件, 不处理宿主元素</span></span><br><span class="line"><span class="comment">// 例如&lt;App /&gt; 或 &lt;Button /&gt;, 但不处理 &lt;div /&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComposite</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> type = element.type;</span><br><span class="line">  <span class="keyword">var</span> props = element.props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> renderedElement;</span><br><span class="line">  <span class="keyword">if</span> (isClass(type)) &#123;</span><br><span class="line">    <span class="comment">// 类组件</span></span><br><span class="line">    <span class="keyword">var</span> publicInstance = <span class="keyword">new</span> type(props);</span><br><span class="line">    <span class="comment">// 设置 props</span></span><br><span class="line">    publicInstance.props = props;</span><br><span class="line">    <span class="comment">// 调用生命周期函数</span></span><br><span class="line">    <span class="keyword">if</span> (publicInstance.componentWillMount) &#123;</span><br><span class="line">      publicInstance.componentWillMount();</span><br><span class="line">    &#125;</span><br><span class="line">    renderedElement = publicInstance.render();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数组件</span></span><br><span class="line">    renderedElement = type(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当元素是宿主元素 (如 &lt;div /&gt;) 时, 终止递归</span></span><br><span class="line">  <span class="keyword">return</span> mount(renderedElement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数只处理宿主元素, 不处理组件</span></span><br><span class="line"><span class="comment">// 例如 &lt;div /&gt; , 但不处理 &lt;App /&gt; 或 &lt;Button /&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountHost</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> type = element.type;</span><br><span class="line">  <span class="keyword">var</span> props = element.props;</span><br><span class="line">  <span class="keyword">var</span> children = props.children || [];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">    children = [children];</span><br><span class="line">  &#125;</span><br><span class="line">  children = children.filter(<span class="built_in">Boolean</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面这段代码不应该放在 reconciler 中</span></span><br><span class="line">  <span class="comment">// 不同渲染器初始化节点的方式也不同</span></span><br><span class="line">  <span class="keyword">var</span> node = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">  <span class="built_in">Object</span>.keys(props).forEach(<span class="function"><span class="params">propName</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (propName !== <span class="string">'children'</span>) &#123;</span><br><span class="line">      node.setAttribute(propName, props[propName]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 挂载子元素</span></span><br><span class="line">  children.forEach(<span class="function"><span class="params">childElement</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 子元素既可以是宿主元素 (如 &lt;div /&gt;) , 也可以是组件 (如：&lt;Button /&gt;) </span></span><br><span class="line">    <span class="comment">// 我们将递归地挂载它们</span></span><br><span class="line">    <span class="keyword">var</span> childNode = mount(childElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这段代码也是由渲染器指定的, 不同渲染器有不同的添加子元素的方法</span></span><br><span class="line">    node.appendChild(childNode);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 DOM 节点作为挂载的结果</span></span><br><span class="line">  <span class="comment">// 递归过程在此处终止</span></span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> type = element.type;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 用户自定义的组件</span></span><br><span class="line">    <span class="keyword">return</span> mountComposite(element);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="comment">// 平台相关的组件 (宿主元素) </span></span><br><span class="line">    <span class="keyword">return</span> mountHost(element);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rootEl = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>);</span><br><span class="line"><span class="keyword">var</span> node = mount(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">rootEl.appendChild(node);</span></span><br></pre></td></tr></table></figure>

<p>现在这段代码可以正常工作了, 但是离实现真正的 reconciler 依然很遥远。缺失的主要部分在于如何支持更新。</p>
<h1 id="内部实例简介">3. 内部实例简介</h1><p>React 的一个特性便是你可以重新渲染任何东西, 并且它不会重新创建 DOM 节点或重新设置 state。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootEl);</span></span><br><span class="line"><span class="xml">// 应当复用已存在的 DOM 节点</span></span><br><span class="line"><span class="xml">ReactDOM.render(<span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootEl);</span></span><br></pre></td></tr></table></figure>

<p>但是, 我们之前的实现只知道能初次挂载节点树。它无法执行更新, 由于它没有保存必要的信息, 比如所有的 <code>publicInstance</code>, 或者哪个 DOM 节点对应哪个组件。<br>stack reconciler 通过将 <code>mount()</code> 函数作为一个方法放入某个类中来解决这个问题。这种方法有缺陷, 目前正在进行重写。不过这就是目前的工作方式。<br>不同于分离的 <code>mountHost</code> 和 <code>mountComposite</code> 函数, 我们将创建两个类：<code>DOMComponent</code> 以及 <code>CompositeComponent</code>。<br>两个类都有接收元素作为参数的构造函数, 以及一个返回已挂载的节点的 <code>mount()</code>方法。我们将把上面代码中的 <code>mount()</code> 替换为一个用于实例化某个的工厂函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instantiateComponent</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> type = element.type;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 用户自定义组件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CompositeComponent(element);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="comment">// 平台相关的组件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DOMComponent(element);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先来实现 <code>CompositeComponent</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompositeComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentElement = element;</span><br><span class="line">    <span class="keyword">this</span>.renderedComponent = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.publicInstance = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getPublicInstance() &#123;</span><br><span class="line">    <span class="comment">// 对于复合组件, 使用此方法可以获取组件实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.publicInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mount() &#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="keyword">this</span>.currentElement;</span><br><span class="line">    <span class="keyword">var</span> type = element.type;</span><br><span class="line">    <span class="keyword">var</span> props = element.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> publicInstance;</span><br><span class="line">    <span class="keyword">var</span> renderedElement;</span><br><span class="line">    <span class="keyword">if</span> (isClass(type)) &#123;</span><br><span class="line">      <span class="comment">// 类组件</span></span><br><span class="line">      publicInstance = <span class="keyword">new</span> type(props);</span><br><span class="line">      <span class="comment">// 设置 props</span></span><br><span class="line">      publicInstance.props = props;</span><br><span class="line">      <span class="comment">// 调用生命周期函数</span></span><br><span class="line">      <span class="keyword">if</span> (publicInstance.componentWillMount) &#123;</span><br><span class="line">        publicInstance.componentWillMount();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回元素树</span></span><br><span class="line">      renderedElement = publicInstance.render();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 函数组件</span></span><br><span class="line">      publicInstance = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 返回元素树</span></span><br><span class="line">      renderedElement = type(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前组件对应的实例</span></span><br><span class="line">    <span class="keyword">this</span>.publicInstance = publicInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据元素树实例化子元素</span></span><br><span class="line">    <span class="comment">// 对于 &lt;div /&gt; 或 &lt;p /&gt; 这样的元素来说, 将返回一个 DOMComponent 实例</span></span><br><span class="line">    <span class="comment">// 对于 &lt;App /&gt; 或 &lt;Button /&gt; 这样的元素来说, 将返回一个 CompositeComponent 实例：</span></span><br><span class="line">    <span class="keyword">var</span> renderedComponent = instantiateComponent(renderedElement);</span><br><span class="line">    <span class="keyword">this</span>.renderedComponent = renderedComponent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对组件的输出进行挂载</span></span><br><span class="line">    <span class="keyword">return</span> renderedComponent.mount();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是, <code>CompositeComponent</code> 的实例并不是用户自定义的组件的实例。<code>CompositeComponent</code> 属于 reconciler 的实现细节, 并不会向用户公开。用户定义的类是从 <code>element.type</code> 中读出的, <code>CompositeComponent</code> 会为其创建一个实例, 并放入 <code>publicInstance</code> 属性中保存。<br>为了避免混淆, 我们把 <code>CompositeComponent</code> 和 <code>DOMComponent</code> 称为 <code>内部实例</code>。由于它们的存在, 使得我们可以将一些需要长期保存的数据与它们相关联, 只有渲染器和 reconciler 知晓内部实例的存在。<br>相反, 我们把用户自定义类的实例称为<code>公共实例</code>。公共实例指代的就是自定义类中的 <code>render()</code> 以及其他方法中的 <code>this</code>。<br>我们将 <code>mountHost</code> 函数进行重构, 得到一个有 <code>mount()</code> 方法的 <code>DOMComponent</code>类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DOMComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentElement = element;</span><br><span class="line">    <span class="keyword">this</span>.renderedChildren = [];</span><br><span class="line">    <span class="keyword">this</span>.node = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getPublicInstance() &#123;</span><br><span class="line">    <span class="comment">// 返回 DOM 节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mount() &#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="keyword">this</span>.currentElement;</span><br><span class="line">    <span class="keyword">var</span> type = element.type;</span><br><span class="line">    <span class="keyword">var</span> props = element.props;</span><br><span class="line">    <span class="keyword">var</span> children = props.children || [];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">      children = [children];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并保存节点</span></span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">    <span class="keyword">this</span>.node = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置属性</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(props).forEach(<span class="function"><span class="params">propName</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (propName !== <span class="string">'children'</span>) &#123;</span><br><span class="line">        node.setAttribute(propName, props[propName]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 创建并保存所有子代</span></span><br><span class="line">    <span class="comment">// 每个子代既可能是一个 DOMComponent, 也可能是一个 CompositeComponent</span></span><br><span class="line">    <span class="comment">// 取决于 element.type 是一个字符串还是函数</span></span><br><span class="line">    <span class="keyword">var</span> renderedChildren = children.map(instantiateComponent);</span><br><span class="line">    <span class="keyword">this</span>.renderedChildren = renderedChildren;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集它们在挂载时返回的 DOM 节点</span></span><br><span class="line">    <span class="keyword">var</span> childNodes = renderedChildren.map(<span class="function"><span class="params">child</span> =&gt;</span> child.mount());</span><br><span class="line">    <span class="comment">// 将子 DOM 节点添加到 DOM 结构中</span></span><br><span class="line">    childNodes.forEach(<span class="function"><span class="params">childNode</span> =&gt;</span> node.appendChild(childNode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 DOM 节点作为挂载的最终结果</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mountHost()</code> 重构前后最大的区别便是我们现在将 <code>this.node</code> 和 <code>this.renderedChildren</code> 与内部 DOMComponent 实例联系在一起。这些属性将在之后用于进行非损毁性更新。<br>以上代码的最终结果, 每个内部实例, 无论是复合组件还是宿主元素, 都保存有其子内部实例。如果一个函数组件 <app> 渲染后的结果是一个 <button> 类组件, </button><button> 类组件的渲染结果是一个 <div>, 那么它们的内部实例树将是这个样子：</div></button></app></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[object CompositeComponent] &#123;</span><br><span class="line">  currentElement: <span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>,</span></span><br><span class="line"><span class="xml">  publicInstance: null,</span></span><br><span class="line"><span class="xml">  renderedComponent: [object CompositeComponent] &#123;</span></span><br><span class="line"><span class="xml">    currentElement: <span class="tag">&lt;<span class="name">Button</span> /&gt;</span>,</span></span><br><span class="line"><span class="xml">    publicInstance: [object Button],</span></span><br><span class="line"><span class="xml">    renderedComponent: [object DOMComponent] &#123;</span></span><br><span class="line"><span class="xml">      currentElement: <span class="tag">&lt;<span class="name">div</span> /&gt;</span>,</span></span><br><span class="line"><span class="xml">      node: [object HTMLDivElement],</span></span><br><span class="line"><span class="xml">      renderedChildren: []</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在 DOM 中你将只能看到 <div>。但是内部实例树中同时包括了组件元素和宿主元素。<br>对于复合组件的内部实例来说, 需要保存：</div></p>
<ul>
<li>当前元素</li>
<li>如果当前元素是类组件, 则需要保存公共实例</li>
<li>下个内部实例, 可以是 DOMComponent, 也可以是 CompositeComponent。</li>
</ul>
<p>对于宿主元素的内部实例来说, 需要保存：</p>
<ul>
<li>当前元素</li>
<li>当前元素对应的DOM节点</li>
<li>所有子元素的内部实例。每个内部实例可以是 DOMComponent, 也可以是 CompositeComponent。</li>
</ul>
<p>如果你还在纠结于内部实例树的结构在复杂应用中到底是怎么样的, <a href="https://github.com/facebook/react-devtools" target="_blank" rel="noopener">React DevTools</a> 能为你提供一个近似的示例。它使用灰色标记出宿主元素实例, 用紫色标记出复合组件实例。</p>
<p><img src="/images/react-stack-reconcilers/01.png" alt>)</p>
<p>最后, 我们将引入一个能够将一个完整的树添加到某个容器节点中的函数, 就像 <code>ReactDOM.render()</code> 所做的那样。同样, 该函数也返回一个公共实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountTree</span>(<span class="params">element, containerNode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建顶级内部实例</span></span><br><span class="line">  <span class="keyword">var</span> rootComponent = instantiateComponent(element);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将顶级内部实例挂载到容器中</span></span><br><span class="line">  <span class="keyword">var</span> node = rootComponent.mount();</span><br><span class="line">  containerNode.appendChild(node);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回顶级内部实例提供的公共实例</span></span><br><span class="line">  <span class="keyword">var</span> publicInstance = rootComponent.getPublicInstance();</span><br><span class="line">  <span class="keyword">return</span> publicInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rootEl = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>);</span><br><span class="line">mountTree(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootEl);</span></span><br></pre></td></tr></table></figure>

<h1 id="卸载">4. 卸载</h1><p>现在我们有了保存有其子级和 DOM 节点的内部实例, 我们可以开始实现卸载卸载功能了。对于复合组件, 卸载对调用一个生命周期方法并向下递归：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompositeComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  unmount() &#123;</span><br><span class="line">    <span class="comment">// 调用生命周期方法</span></span><br><span class="line">    <span class="keyword">var</span> publicInstance = <span class="keyword">this</span>.publicInstance;</span><br><span class="line">    <span class="keyword">if</span> (publicInstance) &#123;</span><br><span class="line">      <span class="keyword">if</span> (publicInstance.componentWillUnmount) &#123;</span><br><span class="line">        publicInstance.componentWillUnmount();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卸载单个渲染后的组件</span></span><br><span class="line">    <span class="keyword">var</span> renderedComponent = <span class="keyword">this</span>.renderedComponent;</span><br><span class="line">    renderedComponent.unmount();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 DOMComponent, 卸载会通知每个子元素执行卸载功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DOMComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  unmount() &#123;</span><br><span class="line">    <span class="comment">// 卸载所有子元素</span></span><br><span class="line">    <span class="keyword">var</span> renderedChildren = <span class="keyword">this</span>.renderedChildren;</span><br><span class="line">    renderedChildren.forEach(<span class="function"><span class="params">child</span> =&gt;</span> child.unmount());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实践中, 卸载 DOMComponent 时还会移除一些事件监听器, 并清空一些缓存。不过我们这里先跳过这些细节。<br>现在我们可以添加一个新的名为 <code>unmountTree(containerNode)</code> 顶级函数, 这个函数与 <code>ReactDOM.unmountComponentAtNode()</code> 类似。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unmountTree</span>(<span class="params">containerNode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从 DOM 节点读取内部实例</span></span><br><span class="line">  <span class="comment">// 目前该功能还不能实现, 我们还需要更改 mountTree() 来在 DOM 节点上保存内部实例</span></span><br><span class="line">  <span class="keyword">var</span> node = containerNode.firstChild;</span><br><span class="line">  <span class="keyword">var</span> rootComponent = node._internalInstance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 卸载树并清空容器</span></span><br><span class="line">  rootComponent.unmount();</span><br><span class="line">  containerNode.innerHTML = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了实现上述功能, 我们需要对 <code>mountTree()</code> 进行修改, 将 <code>_internalInstance</code> 属性添加到根 DOM 节点。为了能够多次调用 <code>mountTree()</code>, 我们还需要让其能够销毁已存在的树。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountTree</span>(<span class="params">element, containerNode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 销毁所有已存在的树</span></span><br><span class="line">  <span class="keyword">if</span> (containerNode.firstChild) &#123;</span><br><span class="line">    unmountTree(containerNode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建顶级内部实例</span></span><br><span class="line">  <span class="keyword">var</span> rootComponent = instantiateComponent(element);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将顶级内部实例添加到容器中</span></span><br><span class="line">  <span class="keyword">var</span> node = rootComponent.mount();</span><br><span class="line">  containerNode.appendChild(node);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存对内部实例的引用</span></span><br><span class="line">  node._internalInstance = rootComponent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回内部实例提供的公共实例</span></span><br><span class="line">  <span class="keyword">var</span> publicInstance = rootComponent.getPublicInstance();</span><br><span class="line">  <span class="keyword">return</span> publicInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在, 运行 <code>unmountTree()</code> 或重复运行 <code>mountTree()</code>, 将会删除旧树并调用组件上的 <code>componentWillUnmount()</code> 生命周期方法。</p>
<h1 id="更新">5. 更新</h1><p>在先前的部分中, 我们实现了卸载功能。但是每次 props 变化都卸载和挂载整个树会让 React 的效率十分低下。reconciler 的目的是尽可能复用已有的实例, 以保存 DOM 节点和状态。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rootEl = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>);</span><br><span class="line"></span><br><span class="line">mountTree(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootEl);</span></span><br><span class="line"><span class="xml">// 应当复用已存在的 DOM</span></span><br><span class="line"><span class="xml">mountTree(<span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootEl);</span></span><br></pre></td></tr></table></figure>

<p>我们将为 <code>DOMComponent</code> 和 <code>CompositeComponent</code> 添加一个名为 <code>receive(nextElement)</code> 的新方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompositeComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  receive(nextElement) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DOMComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  receive(nextElement) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的工作是无论任何时候都尽量保持组件 (以及其所有子代) 都尽可能与 <code>nextElement</code> 提供的描述保持一致。<br>这部分又被称为 <code>virtual DOM diffing</code>, 尽管我们真正做的是递归地遍历内部实例树, 并让每个内部实例接收更新。</p>
<h1 id="更新复合组件">6. 更新复合组件</h1><p>当一个复合组件受到一个新元素时, 我们会调用 <code>componentWillUpdate()</code> 生命周期方法。<br>之后我们用新的 props 重新渲染组件, 并获取新的渲染后的元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompositeComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  receive(nextElement) &#123;</span><br><span class="line">    <span class="keyword">var</span> prevProps = <span class="keyword">this</span>.currentElement.props;</span><br><span class="line">    <span class="keyword">var</span> publicInstance = <span class="keyword">this</span>.publicInstance;</span><br><span class="line">    <span class="keyword">var</span> prevRenderedComponent = <span class="keyword">this</span>.renderedComponent;</span><br><span class="line">    <span class="keyword">var</span> prevRenderedElement = prevRenderedComponent.currentElement;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新自身对应的元素</span></span><br><span class="line">    <span class="keyword">this</span>.currentElement = nextElement;</span><br><span class="line">    <span class="keyword">var</span> type = nextElement.type;</span><br><span class="line">    <span class="keyword">var</span> nextProps = nextElement.props;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出 nextElement render() 的输出是什么, 并更新 publicInstance</span></span><br><span class="line">    <span class="keyword">var</span> nextRenderedElement;</span><br><span class="line">    <span class="keyword">if</span> (isClass(type)) &#123;</span><br><span class="line">      <span class="comment">// 类组件</span></span><br><span class="line">      <span class="comment">// 调用生命周期方法</span></span><br><span class="line">      <span class="keyword">if</span> (publicInstance.componentWillUpdate) &#123;</span><br><span class="line">        publicInstance.componentWillUpdate(nextProps);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新 props</span></span><br><span class="line">      publicInstance.props = nextProps;</span><br><span class="line">      <span class="comment">// 重渲染</span></span><br><span class="line">      nextRenderedElement = publicInstance.render();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 函数组件</span></span><br><span class="line">      nextRenderedElement = type(nextProps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>接下来我们会查看渲染后元素的 <code>type</code>。如果 <code>type</code> 与上次渲染结果相比未发生变化, 则内部实例可以直接更新。<br>例如, 如果第一次返回的结果是 <code>&lt;Button color=&quot;red&quot; /&gt;</code>, 而第二次返回的结果是 <code>&lt;Button color=&quot;blue&quot; /&gt;</code>, 那么我们可以通过把第二次返回的结果传入 <code>receive()</code> 来更新内部实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果渲染后的元素 type 并未改变,</span></span><br><span class="line"><span class="comment">// 复用已存在的组件实例并退出当前函数</span></span><br><span class="line"><span class="keyword">if</span> (prevRenderedElement.type === nextRenderedElement.type) &#123;</span><br><span class="line">  prevRenderedComponent.receive(nextRenderedElement);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>然而, 如果下次渲染后的元素与之前的元素有不同的 type, 那么我们就不能只更新内部实例了。一个 <code>&lt;button&gt;</code> 是不可能变成一个 <code>&lt;input&gt;</code> 的。<br>我们需要卸载当前已有的内部实例, 然后挂载一个与新的渲染后的元素类型对应的内部实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果能执行到这里, 我们需要卸载之前挂载的组件, 挂载一个新的, 并交换二者的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到旧节点以便替换</span></span><br><span class="line">    <span class="keyword">var</span> prevNode = prevRenderedComponent.getHostNode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卸载旧的子代, 挂载一个新的</span></span><br><span class="line">    prevRenderedComponent.unmount();</span><br><span class="line">    <span class="keyword">var</span> nextRenderedComponent = instantiateComponent(nextRenderedElement);</span><br><span class="line">    <span class="keyword">var</span> nextNode = nextRenderedComponent.mount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换对子项的引用</span></span><br><span class="line">    <span class="keyword">this</span>.renderedComponent = nextRenderedComponent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用新节点替换旧节点</span></span><br><span class="line">    <span class="comment">// Note: 这是渲染器特定的代码，</span></span><br><span class="line">    <span class="comment">// 理想情况下应位于CompositeComponent之外：</span></span><br><span class="line">    prevNode.parentNode.replaceChild(nextNode, prevNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上所述, 当一个复合组件受到一个新元素时, 要么它将更新委托给其渲染后的内部实例, 要么将其卸载并在原位置挂载新的实例.<br>还有一种情况, 组件将会重新挂载而不是接收元素, 那就是元素的 <code>key</code> 的更改。由于太过复杂, 在这里我们将不讨论这种情况。<br>请注意, 我们需要向内部实例添加一个新的方法 <code>getHostNode()</code>, 以便在更新期间能够找到特定于平台的节点并替换该节点。对于两个类, 其实现都很简单:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompositeComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  getHostNode() &#123;</span><br><span class="line">    <span class="comment">// 要求 renderedComponent 提供它, 最终会找到 DOMComponent 的节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.renderedComponent.getHostNode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DOMComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  getHostNode() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.node;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="更新宿主元素">7. 更新宿主元素</h1><p>当 DOMComponent 收到一个元素时, 它们需要更新平台特定的视图。对 React DOM 而言, 这意味需要更新 DOM 属性:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DOMComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  receive(nextElement) &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="keyword">this</span>.node;</span><br><span class="line">    <span class="keyword">var</span> prevElement = <span class="keyword">this</span>.currentElement;</span><br><span class="line">    <span class="keyword">var</span> prevProps = prevElement.props;</span><br><span class="line">    <span class="keyword">var</span> nextProps = nextElement.props;    </span><br><span class="line">    <span class="keyword">this</span>.currentElement = nextElement;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除旧属性</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(prevProps).forEach(<span class="function"><span class="params">propName</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (propName !== <span class="string">'children'</span> &amp;&amp; !nextProps.hasOwnProperty(propName)) &#123;</span><br><span class="line">        node.removeAttribute(propName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 设置新属性</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(nextProps).forEach(<span class="function"><span class="params">propName</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (propName !== <span class="string">'children'</span>) &#123;</span><br><span class="line">        node.setAttribute(propName, nextProps[propName]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>接下来将更新其子代。与复合组件不同, DOM 节点可能包含多个子代。<br>在这个简化的示例中, 我们使用内部实例的数组保存其子代, 并对其进行遍历。根据收到的示例的 type 是否匹配先前实例的 type 来更新或替换内部实例。实际上, reconciler 还考虑了元素上 key 属性的存在, 并对插入和删除操作进行跟踪, 但我们将省略此逻辑。<br>我们在列表中收集子项上的 DOM 操作, 以便可以批量执行它们:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由 React 元素组成的数组</span></span><br><span class="line"><span class="keyword">var</span> prevChildren = prevProps.children || [];</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(prevChildren)) &#123;</span><br><span class="line">  prevChildren = [prevChildren];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> nextChildren = nextProps.children || [];</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(nextChildren)) &#123;</span><br><span class="line">  nextChildren = [nextChildren];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是由内部实例组成的数组:</span></span><br><span class="line"><span class="keyword">var</span> prevRenderedChildren = <span class="keyword">this</span>.renderedChildren;</span><br><span class="line"><span class="keyword">var</span> nextRenderedChildren = [];</span><br><span class="line"><span class="comment">// 在遍历子级时, 我们将需要在子级上进行的操作放入数组中</span></span><br><span class="line"><span class="keyword">var</span> operationQueue = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: 以下内容为真实情况的简化版本! 仅用于说明思路!</span></span><br><span class="line"><span class="comment">// 它没有处理重排序, 以及具有 key 的子级</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nextChildren.length; i++) &#123;</span><br><span class="line">  <span class="comment">// 获取该子级现有的内部实例</span></span><br><span class="line">  <span class="keyword">var</span> prevChild = prevRenderedChildren[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前子级没有内部实例, 则将新的子级添加到尾部, 并创建一个新的内部实例并挂载</span></span><br><span class="line">  <span class="keyword">if</span> (!prevChild) &#123;</span><br><span class="line">    <span class="keyword">var</span> nextChild = instantiateComponent(nextChildren[i]);</span><br><span class="line">    <span class="keyword">var</span> node = nextChild.mount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录下需要执行的操作: 添加一个节点</span></span><br><span class="line">    operationQueue.push(&#123;<span class="attr">type</span>: <span class="string">'ADD'</span>, node&#125;);</span><br><span class="line">    nextRenderedChildren.push(nextChild);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 仅当实例的 type 属性相同时才能更新实例</span></span><br><span class="line">  <span class="keyword">var</span> canUpdate = prevChildren[i].type === nextChildren[i].type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果我们无法更新现有实例, 那么我们需要把已有的实例卸载, 然后创建一个新的实例来代替它</span></span><br><span class="line">  <span class="keyword">if</span> (!canUpdate) &#123;</span><br><span class="line">    <span class="keyword">var</span> prevNode = prevChild.getHostNode();</span><br><span class="line">    prevChild.unmount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nextChild = instantiateComponent(nextChildren[i]);</span><br><span class="line">    <span class="keyword">var</span> nextNode = nextChild.mount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录下我们需要执行的操作: 交换节点</span></span><br><span class="line">    operationQueue.push(&#123;<span class="attr">type</span>: <span class="string">'REPLACE'</span>, prevNode, nextNode&#125;);</span><br><span class="line">    nextRenderedChildren.push(nextChild);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果我们可以更新当前内部实例, 那么我们只需让其接收下一个元素, 该内部实例会自己进行更新</span></span><br><span class="line">  prevChild.receive(nextChildren[i]);</span><br><span class="line">  nextRenderedChildren.push(prevChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载所有不应该存在的子代</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = nextChildren.length; j &lt; prevChildren.length; j++) &#123;</span><br><span class="line">  <span class="keyword">var</span> prevChild = prevRenderedChildren[j];</span><br><span class="line">  <span class="keyword">var</span> node = prevChild.getHostNode();</span><br><span class="line">  prevChild.unmount();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录下我们需要执行的操作: 移除节点</span></span><br><span class="line">  operationQueue.push(&#123;<span class="attr">type</span>: <span class="string">'REMOVE'</span>, node&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将子代列表指向更新后的版本</span></span><br><span class="line"><span class="keyword">this</span>.renderedChildren = nextRenderedChildren;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>最后, 我们将执行 DOM 操作。真正的 reconciler 代码会更复杂, 因为其还会处理节点移动:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理操作队列</span></span><br><span class="line">    <span class="keyword">while</span> (operationQueue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> operation = operationQueue.shift();</span><br><span class="line">      <span class="keyword">switch</span> (operation.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">        <span class="keyword">this</span>.node.appendChild(operation.node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'REPLACE'</span>:</span><br><span class="line">        <span class="keyword">this</span>.node.replaceChild(operation.nextNode, operation.prevNode);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'REMOVE'</span>:</span><br><span class="line">        <span class="keyword">this</span>.node.removeChild(operation.node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上便是宿主组件更新的全部过程。</p>
<h1 id="顶级更新">8. 顶级更新</h1><p>到这里, 我们已经分别在 <code>CompositeComponent</code> 和 <code>DOMComponent</code> 上实现了 <code>receive(nextElement)</code> 方法, 我们可以更改顶级更新方法 <code>mountTree()</code> 函数, 让其在元素 <code>type</code> 一致时可以使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountTree</span>(<span class="params">element, containerNode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查是否已经有存在的树</span></span><br><span class="line">  <span class="keyword">if</span> (containerNode.firstChild) &#123;</span><br><span class="line">    <span class="keyword">var</span> prevNode = containerNode.firstChild;</span><br><span class="line">    <span class="keyword">var</span> prevRootComponent = prevNode._internalInstance;</span><br><span class="line">    <span class="keyword">var</span> prevElement = prevRootComponent.currentElement;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尽可能复用已存在的 root 组件</span></span><br><span class="line">    <span class="keyword">if</span> (prevElement.type === element.type) &#123;</span><br><span class="line">      prevRootComponent.receive(element);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则的话, 卸载已存在的树</span></span><br><span class="line">    unmountTree(containerNode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在调用 <code>mountTree()</code> 更新相同类型时不会造成不必要的破坏。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rootEl = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>);</span><br><span class="line"></span><br><span class="line">mountTree(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootEl);</span></span><br><span class="line"><span class="xml">// 复用已存在的 DOM 节点</span></span><br><span class="line"><span class="xml">mountTree(<span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootEl);</span></span><br></pre></td></tr></table></figure>

<p>以上就是 React 内部是如何工作的。</p>
<h1 id="未实现的功能">9. 未实现的功能</h1><p>该文档是源码的简化版本, 还有几个很重要的方面是我们没有兼顾到的:</p>
<ul>
<li>组件应当能够渲染 <code>null</code>, 而 <code>reconciler</code> 应当可以处理 “ empty slots” 的情况。</li>
<li>reconciler 会从元素中读取 key 属性, 并据此把内部实例和元素对应起来。一系列 React 特性的实现都与此有关。</li>
<li>除了复合组件和宿主类组件外, 还应该有两个类: <code>text</code> 类以及 <code>empyt</code> 类。它们分别对应文字节点以及渲染 <code>null</code> 带来的空组件。</li>
<li>渲染器通过外部注入的方法告知 reconciler 当前的宿主环境。</li>
<li>子列表的更新逻辑被提取到一个称为 <code>ReactMultiChild</code> 的类中, 供 React DOM 和 React Native 使用。</li>
<li>reconciler 还实现了对 <code>setState()</code> 的支持, 在事件处理器内部, 多个更新被合并为一个更新。</li>
<li>reconciler 还负责将 ref 附加到对应的复合组件以及宿主节点上。</li>
<li>在 DOM 准备就绪后调用的生命周期方法(比如 componentDidMount 以及 componentDidUpdate) 会被收集到 <code>callback queues</code> 中, 并在单个 batch 中执行。</li>
<li>React 会将当前更新信息放入一个称为 <code>transaction</code> 的对象中。</li>
</ul>
<h1 id="进入源码中">10. 进入源码中</h1><p>略</p>
<h1 id="未来可能实现的特性">11. 未来可能实现的特性</h1><p>Stack reconciler 有局限性, 比如不能中断任务执行, 不能为任务分派优先级等。新的 reconciler 称为 Fiber reconciler, 正在开发中。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/13/react-contribute/" rel="next" title="React贡献手册">
                <i class="fa fa-chevron-left"></i> React贡献手册
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/17/react-components-elements-and-instances/" rel="prev" title="React Components, Elements, and Instances">
                React Components, Elements, and Instances <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Mett Li</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#实现说明"><span class="nav-text">1. 实现说明</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#从零开始构建-React"><span class="nav-text">1.1. 从零开始构建 React</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-text">1.2. 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归挂载"><span class="nav-text">1.3. 递归挂载</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#挂载宿主元素-host-elements"><span class="nav-text">2. 挂载宿主元素 (host elements)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内部实例简介"><span class="nav-text">3. 内部实例简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#卸载"><span class="nav-text">4. 卸载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#更新"><span class="nav-text">5. 更新</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#更新复合组件"><span class="nav-text">6. 更新复合组件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#更新宿主元素"><span class="nav-text">7. 更新宿主元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#顶级更新"><span class="nav-text">8. 顶级更新</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#未实现的功能"><span class="nav-text">9. 未实现的功能</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进入源码中"><span class="nav-text">10. 进入源码中</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#未来可能实现的特性"><span class="nav-text">11. 未来可能实现的特性</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mett Li</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
