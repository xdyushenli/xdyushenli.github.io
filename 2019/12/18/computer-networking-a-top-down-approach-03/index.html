<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="计算机网络,TCP,UDP,">










<meta name="description" content="本章详细介绍了运输层相关的知识, 从 TCP 和 UDP 运输层协议入手, 主要探讨如下两个问题：  两个实体如何在一种会丢失或损坏数据的媒体上进行可靠通信? 如何控制运输层实体的传输速率以避免网络拥塞, 以及如何从拥塞中恢复过来?  1. 概述1.1. 运输层的层级运输层介于应用层之下, 网络层之上。 1.2. 运输层提供的功能运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信功能。所谓逻">
<meta name="keywords" content="计算机网络,TCP,UDP">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络：自顶向下方法读书笔记（三）">
<meta property="og:url" content="http://yoursite.com/2019/12/18/computer-networking-a-top-down-approach-03/index.html">
<meta property="og:site_name" content="敝舍">
<meta property="og:description" content="本章详细介绍了运输层相关的知识, 从 TCP 和 UDP 运输层协议入手, 主要探讨如下两个问题：  两个实体如何在一种会丢失或损坏数据的媒体上进行可靠通信? 如何控制运输层实体的传输速率以避免网络拥塞, 以及如何从拥塞中恢复过来?  1. 概述1.1. 运输层的层级运输层介于应用层之下, 网络层之上。 1.2. 运输层提供的功能运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信功能。所谓逻">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/01.png">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/02.png">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/03.png">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/04.png">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/05.png">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/06.png">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/07.png">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/08.png">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/09.png">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/10.png">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/11.png">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/12.png">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/13.png">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/14.png">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/15.png">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/16.png">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/17.png">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/18.png">
<meta property="og:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/19.jpg">
<meta property="og:updated_time" content="2020-03-30T12:55:33.443Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="计算机网络：自顶向下方法读书笔记（三）">
<meta name="twitter:description" content="本章详细介绍了运输层相关的知识, 从 TCP 和 UDP 运输层协议入手, 主要探讨如下两个问题：  两个实体如何在一种会丢失或损坏数据的媒体上进行可靠通信? 如何控制运输层实体的传输速率以避免网络拥塞, 以及如何从拥塞中恢复过来?  1. 概述1.1. 运输层的层级运输层介于应用层之下, 网络层之上。 1.2. 运输层提供的功能运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信功能。所谓逻">
<meta name="twitter:image" content="http://yoursite.com/images/computer-networking-a-top-down-approach-03/01.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/12/18/computer-networking-a-top-down-approach-03/">





  <title>计算机网络：自顶向下方法读书笔记（三） | 敝舍</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">敝舍</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/18/computer-networking-a-top-down-approach-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mett Li">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="敝舍">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">计算机网络：自顶向下方法读书笔记（三）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-18T10:05:24+08:00">
                2019-12-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本章详细介绍了运输层相关的知识, 从 TCP 和 UDP 运输层协议入手, 主要探讨如下两个问题：</p>
<ul>
<li>两个实体如何在一种会丢失或损坏数据的媒体上进行可靠通信?</li>
<li>如何控制运输层实体的传输速率以避免网络拥塞, 以及如何从拥塞中恢复过来?</li>
</ul>
<h1 id="概述">1. 概述</h1><h2 id="运输层的层级">1.1. 运输层的层级</h2><p>运输层介于应用层之下, 网络层之上。</p>
<h2 id="运输层提供的功能">1.2. 运输层提供的功能</h2><p>运输层协议为运行在不同主机上的应用进程之间提供了<code>逻辑通信</code>功能。所谓<code>逻辑通信</code>, 是指应用进程通过运输层提供的功能进行通信, 而无需关心承载这些报文的物理基础设施细节。</p>
<h2 id="运输层实现的位置">1.3. 运输层实现的位置</h2><p>运输层协议是在端系统中而非路由器中实现的。</p>
<h2 id="运输层与网络层的区别">1.4. 运输层与网络层的区别</h2><p>网络层提供了主机之间的逻辑通信, 运输层提供了运行在不同主机上的应用进程之间的逻辑通信。</p>
<h2 id="运输层分组的名称">1.5. 运输层分组的名称</h2><p>运输层的分组称为<code>报文段（segment）</code>。</p>
<h1 id="多路复用与多路分解">2. 多路复用与多路分解</h1><p>在之前的内容中我们了解到, 在接收主机中的运输层实际上并没有直接把数据交付给进程, 而是将数据交给了一个中间套接字。每个套接字都有唯一标识符用于与其他套接字做区分。对应的, 每个运输层报文段中都会有几个字段, 用于唯一标识套接字。在接收端, 运输层检查这些字段, 标识出接收套接字, 进而将报文段定向到该套接字。<br>将运输层报文段中的数据交付到正确的套接字的工作称为<code>多路分解（demultiplexing）</code>。<br>在源主机从不同套接字中收集数据块,并未每个数据块封装上首部信息（用于以后分解）从而生成报文段, 然后将报文段传递到网络层, 所有这些工作称为<code>多路复用（multiplexing）</code>。</p>
<h2 id="多路复用与多路分解的报文结构">2.1. 多路复用与多路分解的报文结构</h2><p>要实现多路复用和多路分解, 要同时满足两个要求：</p>
<ol>
<li>套接字有唯一标识符。</li>
<li>报文中有特殊字段将报文导向某个套接字。<br>这些特殊的字段便是<code>源端口号字段（source port number field）</code>以及<code>目的端口号字段（destination port number field）</code>, TCP报文段 和 UDP 报文段中还有其他一些字段。<br>端口号是一个 16 位比特的数, 其大小在 0 ~ 65535 之间, 其中 0 ~ 1023 为<code>周知端口号（well-know port number）</code>, 专门为一些诸如 HTTP 等的协议保留。如果应用程序开发者编写的是一个<code>周知协议</code>的服务器端, 那么开发者必须为其分配一个相应的周知端口号。通常, 应用程序的客户端让运输层自动地（并且是透明地）分配端口号, 而服务器端则分配一个特定的端口号。</li>
</ol>
<h2 id="无连接的多路复用和多路分解">2.2. 无连接的多路复用和多路分解</h2><p>最常见的无连接多路复用和多路分解便是 UDP。<br>一个 UDP 套接字是由一个二元组唯一标识的, 该二元组包含一个<code>目的 IP 地址</code>和一个<code>目的端口号</code>。</p>
<h2 id="有连接的多路复用和多路分解">2.3. 有连接的多路复用和多路分解</h2><p>最常见的有连接的多路复用和多路分解便是 TCP。<br>一个 TCP 套接字是由一个四元组唯一标识的, 该四元组包括一个<code>源 IP 地址</code>、一个<code>源端口号</code>、一个<code>目的 IP 地址</code>以及一个<code>目的端口号</code>。<br>尤其与 UDP 不同的是, 两个具有不同源 IP 地址或两个具有不同源端口号的 TCP 报文段会被定向到两个不同的套接字（即<code>连接套接字</code>）, 除非 TCP 报文段携带了初始的创建连接的请求, 它们会被定向到同一个套接字（即<code>欢迎套接字</code>）。</p>
<h1 id="无连接运输：UDP">3. 无连接运输：UDP</h1><p><strong>运输层最低限度必须提供一种复用/分解服务, 以便在网络层与正确的应用层进程之间传递数据。</strong><br>由 <a href="https://tools.ietf.org/html/rfc768" target="_blank" rel="noopener">RFC768</a> 定义的 UDP 只是做了运输层协议能够做到最少工作。除了复用/分解服务以及差错检测外, 它几乎没有对 IP 协议增加任何东西。因此 UDP 并不如 TCP 那么可靠, 属于<code>尽力而为型的协议</code>。</p>
<h2 id="为什么要使用-UDP">3.1. 为什么要使用 UDP?</h2><p>与 TCP 相比, UDP 具有如下几种优势让人：</p>
<ol>
<li><strong>对发送什么数据以及何时发送的应用层控制更为精细。</strong>采用 UDP 时, 只要进程把数据传入 UDP, UDP 便会立刻将此数据打包进 UDP 报文段并发送。而采用 TCP 时, 由于其拥塞控制机制的存在, 因此常常会遏制发送速率。对于一些要求最小发送速率, 且能容忍一部分数据丢失的应用而言, UDP 显然要比 TCP 要好。</li>
<li><strong>无需建立连接。</strong></li>
<li><strong>无连接状态。</strong>TCP 需要在端系统中维护连接状态, 包括接收和发送缓存、拥塞控制参数以及序号与确认号的参数。而 UDP 无需维护连接状态, 因此也无需跟踪这些参数。一般来说, 服务器中某个特定功能的应用程序运行在 UDP 上而不是 TCP 上时, 能支持更多的用户。</li>
<li><strong>分组首部开销小。</strong>每个 TCP 报文段都有 20 个字节的首部开销, 而 UDP 仅有 8 个字节的首部开销。</li>
</ol>
<h2 id="UDP-报文段结构">3.2. UDP 报文段结构</h2><p>UDP 报文段由两大部分组成, 一部分是<code>数据字段</code>：由应用数据报文占据; 另一部分是<code>首部字段</code>, 共有 4 个, 每个两字节（16 比特）, 共 8 字节, 分别是：</p>
<ul>
<li><code>源端口号</code>：发送主机中 UDP 报文段的源套接字所对应的端口号。</li>
<li><code>目的端口号</code>：接收主机中 UDP 报文段的目的套接字所对应的端口号。</li>
<li><code>长度</code>：指示 UDP 报文段中的字节数（首部加数据）, 不固定。</li>
<li><code>校验和</code>：接收方通过检验和来检测该报文段中是否出现了差错。计算方法是对报文段中的所有 16 比特的字进行不进位加法, 之后对得到的数字进行反码计算。在接收方, 全部报文段中的 16 比特的字相加（包括校验和）, 结果应该是 1111 1111 1111 1111。如果这些比特之一为 0, 那么肯定就出现了差错。</li>
</ul>
<p><img src="/images/computer-networking-a-top-down-approach-03/01.png" alt="UDP报文结构"></p>
<p>值得注意的是, 虽然 UDP 提供差错检测, 但对差错恢复无能为力。<br>UDP 虽然是不可靠传输协议, 但是基于 UDP 的应用程序是可以实现可靠传输的, 这可通过在应用程序（应用层）中建立可靠性机制来完成。 </p>
<h1 id="可靠数据传输原理">4. 可靠数据传输原理</h1><p>实现可靠数据传输的协议称为<code>可靠数据传输协议（reliable data transfer protocol）</code>。由于现实中可靠数据传输协议的下层协议也许是不可靠的, 因此实现可靠传输是一项十分困难的任务。</p>
<h2 id="构造可靠数据传输协议">4.1. 构造可靠数据传输协议</h2><p>我们将从完全可靠信道开始, 逐步降低信道的可靠度以贴近实际, 来探讨如何建立可靠数据传输。<br>在这里有一个贯穿整个讨论的假设, 那就是：<strong><em>底层信道不会对分组重排序, 分组将以它们发送的次序进行交付。无论是接收方还是发送方, 每次都只接收/发送一个分组。</em></strong></p>
<h3 id="经过完全可靠信道的可靠数据传输：rdt1-0">4.1.1. 经过完全可靠信道的可靠数据传输：rdt1.0</h3><p>rdt1.0 的<code>有限状态机（Finite-State Machine, FSM）</code>定义如图所示。<br><code>FSM 描述图</code>使用虚线表示初始状态, 箭头表示状态迁移, 引起变迁的事件显示在表示变迁的横线上方, 事件发生时采取的动作表示在横线下方。</p>
<p><img src="/images/computer-networking-a-top-down-approach-03/02.png" alt="rdt1.0"></p>
<p>由于信道是完全可靠的, 因此接收方并不需要提供任何反馈信息给发送方。且我们假定<strong><em>接收方接收数据的速率与发送方发送数据的速率一样快,</em></strong> 因此接收方并不需要请求发送方降低发送速度。</p>
<h3 id="经过具有比特差错信道的可靠数据传输：rdt2-0">4.1.2. 经过具有比特差错信道的可靠数据传输：rdt2.0</h3><p>一种更为贴近实际的底层信道模型是<strong><em>分组中的比特可能受损的信道模型</em></strong>。在分组的传输、传播或缓存的过程中, 这种比特差错常常会出现在网络的物理部件中。</p>
<h4 id="自动重传请求（ABQ）协议">4.1.2.1. 自动重传请求（ABQ）协议</h4><p>针对可能发生的比特差错问题, 一种解决方式是使用<code>肯定确认（postive acknowledgement）</code>报文和<code>否定确认（negative acknowledegment）</code>报文。这些控制报文使得接收方可以让发送方知道哪些内容被正确接收, 哪些内容接收有误需要重发。基于这种重传机制的可靠数据传输协议称为<code>自动重传请求（Automatic Repeat reQuest, ARQ）协议</code>。</p>
<p>ARQ 协议需要三种协议功能以实现通过具有比特差错信道的可靠数据传输：</p>
<ul>
<li><code>差错检测</code>：用检验和字段实现差错检测。</li>
<li><code>接收方反馈</code>：接收方将发送 <code>ACK 分组</code>与 <code>NAK 分组</code>, 为发送方提供信息。</li>
<li><code>重传</code>：接收方收到有差错的分组时, 发送方将重传该分组。</li>
</ul>
<h4 id="rdt2-0">4.1.2.2. rdt2.0</h4><p>rdt2.0 发送方和接收方的 FSM 图如下。</p>
<p><img src="/images/computer-networking-a-top-down-approach-03/03.png" alt="rdt2.0"></p>
<p>注意以下事实：<strong>当发送方处于等待 ACK 或 NAK 的状态时, 它不能从上层获取更多的数据。</strong>只有发送方确信接收方已正确接收当前分组后, 才会发送新的分组。具有这种行为的协议被称为<code>停等（stop-and-wait）协议</code>。</p>
<h4 id="rdt2-1">4.1.2.3. rdt2.1</h4><p>rdt2.0 看上去很不错, 但是有一个致命的缺陷, 那就是<strong>没有考虑 ACK 或 NAK 分组受损的可能性。</strong><br>为了应对这种情况, 我们需要同时采取两种措施：</p>
<ol>
<li>为 ACK 和 NAK 分组添加检验和字段, 以此来检测分组是否损坏。</li>
<li>在发送分组和控制分组中添加<code>序号（sequence number）</code>字段。<em>当发送方收到损坏的 ACK 分组或收到 NAK 分组时会重传当前的数据分组。</em><br>rdt2.1 发送方和接收方的 FSM 图如下。</li>
</ol>
<p><img src="/images/computer-networking-a-top-down-approach-03/04.png" alt="rdt2.1"></p>
<p><img src="/images/computer-networking-a-top-down-approach-03/05.png" alt="rdt2.1"></p>
<p>应当注意到, 由于 rdt2.1 是停等协议, 因此只需要 1 比特序号就够了。</p>
<h4 id="rdt2-2">4.1.2.4. rdt2.2</h4><p><strong>rdt2.2 实现了与 rdt2.1 相同的效果。</strong>不同的是, rdt2.2 是在比特差错信道上实现的<strong>一个无 NAK 的可靠数据传输协议。</strong><br>rdt2.2 的重传条件与 rdt2.1 有所不同。<em>当收到冗余 ACK 或损坏的 ACK 包时, 发送方会重传当前分组。</em><br>rdt2.2 发送方和接收方的 FSM 图如下。</p>
<p><img src="/images/computer-networking-a-top-down-approach-03/06.png" alt="rdt2.2"></p>
<p><img src="/images/computer-networking-a-top-down-approach-03/07.png" alt="rdt2.2"></p>
<h3 id="经过具有比特差错的丢包信道的可靠数据传输：rdt3-0">4.1.3. 经过具有比特差错的丢包信道的可靠数据传输：rdt3.0</h3><p><strong><em>在实际中, 底层信道不仅会发生比特差错, 还可能会发生丢包。</em></strong>因此在 rdt2.2 的基础上, rdt3.0 需要关注另外两个问题：怎样检测丢包以及发生丢包后该做什么。<br>在这里, 我们把检测和恢复丢包的工作交给发送方。假定发送方传输一个数据分组, 该分组或接收方发送的 ACK 发生了丢失。在这两种情况下, 发送方都收不到应当到来的接收方的相应。如果发送方愿意等待足够长的时间（即发送方与接收方之间的一个往返时延加上接收方处理一个分组所需的时间）以确认分组已丢失, 则它只需要重传丢失分组即可。<br>为了实现这种重传机制, 需要一个<code>倒计时定时器（countdown timer）</code>。在实践中, 发送方会明智地选择一个时间值, 以判定可能发生了丢包。如果在这个时间内没有收到正确的 ACK, 则会重传该分组。<br>rdt3.0 发送方的 FSM 图如下。</p>
<p><img src="/images/computer-networking-a-top-down-approach-03/08.png" alt="rdt3.0"></p>
<p>因为分组序号在 0 和 1 之间交替, 因此 rdt3.0 又称为<code>比特交替（alternative-bit）协议</code>。<br>我们注意到, rdt2.2 的发送方与 rdt3.0 的发送方的区别在于添加了定时器, 这会在发送方和接收方之间的信道中引入了<code>冗余数据分组（duplicate data packet）</code>。而 rdt2.2 的接收方已经能处理冗余数据分组, 因此<strong>rdt2.2 中的接收方也能充当 rdt3.0 中的接收方。</strong><br>至此, 通过引入检验和、肯定确认、否定确认、序号和定时器, 我们得到了一个可靠数据传输协议！</p>
<h2 id="流水线可靠数据传输协议">4.2. 流水线可靠数据传输协议</h2><p>rdt3.0 是一个功能正确的协议, 但其性能却差强人意。<strong>影响 rdt3.0 性能的核心问题在于它是一个停等协议。</strong>停等协议一次只能发送一个分组, 并且只有在收到 ACK 后才会发送下一个分组, 而将分组送入信道的时间只占整个发送时间的一小部分（大部分是 RTT）, 因此停等协议发送方的信道在大部分时间都是空闲状态, 不发送也不接收任何数据, 这对性能是一种极大的浪费！<br>这种性能问题有一个简单的解决方法, 那就是：<strong>不以停等方式运行, 允许发送方发送多个分组而无需等待确认。</strong>由于从发送方看来, 这种发送方式可以看做是将分组填充到一条流水线中, 因此这种技术被称为<code>流水线（pipelining）</code>。</p>
<p><img src="/images/computer-networking-a-top-down-approach-03/09.png" alt="停等和流水线的发送"></p>
<p>流水线技术会对可靠数据传输协议带来如下影响：</p>
<ol>
<li><strong>必须增大序号范围</strong>。因为同时会传输多个分组, 而每个输送中的分组必须有一个唯一的序号。</li>
<li><strong>协议的发送方和接收方两端需缓存多个分组。</strong>发送方最低限度应该能缓存还未发送的分组, 接收方需要能够缓存已正确接收的分组。</li>
</ol>
<p><strong>所需序号范围和对缓存的要求取决于数据传输协议如何处理丢失、损坏或延时过大的分组。</strong>解决流水线差错恢复有两种基本方法, 分别是：<code>回退 N 步（Go-Back-N, GBN）</code>和<code>选择重传（Selective Repeat, SR）</code>。</p>
<h3 id="回退-N-步">4.2.1. 回退 N 步</h3><p>下图可以很好地说明 GBN 协议的流程, 以及为什么 GBN 协议的性能十分低下。<br><img src="/images/computer-networking-a-top-down-approach-03/10.png" alt="GBN协议"><br>如图所示, 当窗口中间有一个包没有被确认的时候, 发送方会发送在这个包之后的所有包, 哪怕之后的包都已经收到了确认信息!</p>
<h3 id="选择重传">4.2.2. 选择重传</h3><p>顾名思义, 选择重传协议只会让发送方发送那些它怀疑在接收方出错的分组而避免了不必要的重传。<br><img src="/images/computer-networking-a-top-down-approach-03/11.png" alt="选择重传协议"><br>另外, 应当注意的是, <strong>选择重传协议的窗口长度必须小于或等于序号空间大小的一半,</strong> 否则接收方会产生混淆。</p>
<h1 id="面向连接的运输：TCP">5. 面向连接的运输：TCP</h1><h2 id="TCP-连接">5.1. TCP 连接</h2><p>TCP 被称为是<code>面向连接的</code>, 而这种连接是<strong>一种逻辑上的连接, 其共同状态仅保留在两个通信端系统的 TCP 程序中。</strong>由于 TCP 协议只在端系统中运行, 而不在中间的网络节点( 路由器和链路层交换机 )中运行, 所以<strong>中间的网络节点不会维持 TCP 连接状态。</strong></p>
<h3 id="初步了解三次握手">5.1.1. 初步了解三次握手</h3><p>在发送数据之前, TCP 首先要在两个进程之间建立连接。整个过程的简单描述如下: </p>
<ol>
<li>客户端首先发送一个特殊的 TCP 报文段。</li>
<li>服务器使用另一个特殊的 TCP 报文段来响应。</li>
<li>客户以第三个特殊报文段作为响应。<br>由于整个建立连接的过程共发送了三个报文段, 因此这个过程被称为<code>三次握手(three-way handshake)</code>。<br>应当注意的是, <strong>前两个报文段不承载有效载荷( 即应用层数据 ), 第三个报文段可以承载有效载荷。</strong></li>
</ol>
<h3 id="建立连接后的客户端">5.1.2. 建立连接后的客户端</h3><p>在建立起一条连接之后, 两个主机之间就可以开始发送数据了。<br>为了发送数据, 在客户端中, TCP 会把数据引导到该连接的<code>发送缓存(send buffer)</code>中, 发送缓存是在三次握手期间设置的缓存之一。接下来 TCP 会时不时地从发送缓存中取出一块数据, 并将数据传递到网络层。<br>TCP 每次从缓存中取出的数据长度受<code>最大报文段长度(Maximum Segment Size, MSS)</code>限制。MSS 通常根据最初确定的、由本地发送主机发送的<code>最大链路层帧长度(Maximum Transmission Unit, MTU)</code>来设置。设置该 MSS 的标准是要<strong>保证一个 TCP 报文段 (应用层数据 + 40 个字节的TCP 首部)能够适合单个链路层帧</strong>。以太网和 PPP 链路层协议都具有 1500 字节的 MTU, 因此 <strong>MSS 的典型值为 1460 字节。</strong><br>需要注意的是, <strong>MSS 指的是在报文段中的应用层数据的最大长度, 不包括 TCP 首部的长度。</strong></p>
<h2 id="TCP报文段结构">5.2. TCP报文段结构</h2><p>下图为 TCP 报文段的结构。<br><img src="/images/computer-networking-a-top-down-approach-03/12.png" alt="TCP 报文段结构"><br>接下来逐条对其进行分析:</p>
<ul>
<li><code>源端口号</code>、<code>目的端口号</code>、<code>校验和</code>: 和 UDP 中的用途一样。</li>
<li>32 位的<code>序号字段(sequence number field)</code>以及 32 位的<code>确认号字段(acknowledge number field)</code>: 用于实现可靠数据传输, 具体讨论见后。</li>
<li>16 位的<code>接收窗口字段(receive window field)</code>: 该字段用于实现流量控制。该字段指示出了接收方可以接收的字节数量。</li>
<li>4 位的<code>首部长度字段(header length field)</code>: 该字段以 32 比特为单位, 指示当前 TCP 报文段的首部长度。</li>
<li>6 位的<code>标志字段(flag field)</code>: <code>ACK</code>用于表明该报文段包括一个对已被成功接收的报文段的确认。<code>RST</code>、<code>SYN</code>、<code>FIN</code> 均用于连接的建立与拆除。其他字段在实践中并没有使用。</li>
<li>可选与变长的<code>选项字段(options field)</code>: 该字段用于发送方和接收方协商最大报文段长度(MSS), 或在高速网络环境下用作窗口调节因子时使用。</li>
</ul>
<h3 id="TCP-报文段中的序号和确认号">5.2.1. TCP 报文段中的序号和确认号</h3><p>首先要明确一点, <strong>TCP 报文段中的序号与确认号不是报文段流的序号, 而是报文段中所包含的数据在字节流中的序号!</strong></p>
<blockquote>
<p>一个报文段的序号是该报文段首字节在字节流中的编号。<br>一个报文段中的确认号是发送主机期望接收到的下一字节的序号。</p>
</blockquote>
<p>在填写确认号时, TCP 只确认从起点开始至第一个丢失字节为止的字节, 之前的字节已全部确认。这种确认方式被称为<code>累计确认(cumulative acknowledge)</code>。<br>另外, <strong>初始序号并不是每次都是从 0 开始的, 而是随机选择的。</strong>这样减少将那些仍存在于网络中、来自两台主机先前已终止的连接的报文段, 误认为是新连接产生的报文的可能性。<br><strong>只有发送端发送了新数据并被成功接收后, 接收端返回的确认号才会增加。</strong>如果收到的是不含数据的报文段, 那么接收端返回的确认号不会变化。</p>
<h2 id="往返时间的估计与超时">5.3. 往返时间的估计与超时</h2><p>TCP 使用超时重传机制来处理报文段的丢失问题, 那么超时的时间是如何估计的呢? 下面便来介绍一下:<br>在任意时刻, TCP 会选择一个只发送过一次、没有重传过且尚未确认的报文段, 将这个报文段从发送到确认的时间作为一个 <code>SampleRTT</code>。这个过程会在数据发送的过程中多次发生, 生成多个 SampleRTT。<br>TCP 会维持一个 SampleRTT 的均值, 称为 <code>EstimatedRTT</code>。每当获得新的 SampleRTT 时, 都会根据下面的式子来更新 EstimatedRTT。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EstimatedRTT = (1 - α) * EstimatedRTT + α * SampleRTT</span><br></pre></td></tr></table></figure>

<p><strong>在 <a href="https://tools.ietf.org/html/rfc6298" target="_blank" rel="noopener">RFC6289</a> 中, 推荐使用的 α 值为 0.125。</strong><br>值得注意的是, <strong>EstimatedRTT 是 SampleRTT 的一个加权平均值, 其中对新样本所赋予的权值要大于对旧样本赋予的权值。</strong>这很好理解, 越新的样本就越能反映当前的网络状况。这种平均的方式被称为<code>指数加权移动平均(Exponential Weighted Moving Average, EWMA)</code>。<br>除此之前, TCP 还会维持一个用于表示 SampleRTT 偏离 EstimatedRTT 的程度的值, 称为 <code>DevRTT</code>。同样的, 每当获得新的 SampleRTT 时, 都会根据下面的式子来更新 EstimatedRTT。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DevRTT = (1 - β) * DevRTT + β * | SampleRTT - EstimatedRTT|</span><br></pre></td></tr></table></figure>

<p><strong>在 <a href="https://tools.ietf.org/html/rfc6298" target="_blank" rel="noopener">RFC6289</a> 中, 推荐使用的 β 值为 0.25。</strong><br><strong>DevRTT 的主要作用便是用于估计当前网络的波动程度。</strong>如果网络波动很大, 那么不同的 SampleRTT 波动也会很大, 相应的 DevRTT 也会很大; 如果网络波动很小, 那么 DevRTT 也会很小。<br>有了 EstimatedRTT 和 DevRTT, 那么是时候设置最终的 TCP 超时间隔了。很明显, 超时间隔应该大于 EstimatedRTT, 否则会造成不必要的重传, 但也不能太大, 最好是设置为 EstimatedRTT 加上一定余量。当 SampleRTT 波动很大时, 余量也应该大一些; 当波动较小时, 余量也应该小一些。因此最终的式子为: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimeoutInterval = EstimatedRTT + 4 * DevRTT</span><br></pre></td></tr></table></figure>

<p><strong>在 <a href="https://tools.ietf.org/html/rfc6298" target="_blank" rel="noopener">RFC6289</a> 中, 推荐的初始 TimeoutInterval 为 1 秒。</strong><br><strong>当出现超时后, TimeoutInterval 将加倍。然而, 只要收到报文段并更新 EstimatedRTT, 就使用上述公式再次计算 TimeoutInterval。</strong></p>
<h2 id="可靠数据传输">5.4. 可靠数据传输</h2><p>那么 TCP 是怎样在 IP 提供的不可靠服务之上建立可靠数据传输的呢? 通过下面的伪代码可以一窥究竟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/* 假设发送方不受 TCP 流量和拥塞控制的限制, 来自上层的数据长度小于 MSS, 且数据传送只在一个方向进行。 */</span><br><span class="line">NextSeqNum=InitialSeqNumber</span><br><span class="line">/* SendBase 是最小的、未被确认的字节的序号, 因此 SendBase - 1 就是接收方已正确按序号接收到的数据的最后一个字节的序号。 */</span><br><span class="line">SendBase=InitialSeqNumber</span><br><span class="line">loop (forever) &#123;</span><br><span class="line">    switch (事件)</span><br><span class="line">        事件: 收到从上层应用程序传来的数据</span><br><span class="line">            生成序号为 NextSeqNum 的 TCP 报文段</span><br><span class="line">            if (当前无定时器) &#123;</span><br><span class="line">                根据最近的 EstimatedRTT 和 DevRTT 设置超时间隔</span><br><span class="line">                启动定时器</span><br><span class="line">            &#125;</span><br><span class="line">            向 IP 传递报文段</span><br><span class="line">            NextSeqNum=NextSeqNum+length(data)</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        事件: 超时</span><br><span class="line">            重传具有最小序号的、仍未收到应答的报文段</span><br><span class="line">            将超时的间隔加倍</span><br><span class="line">            启动定时器</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        事件: 收到 ACK 包, ACK 字段值为 y</span><br><span class="line">            if (y &gt; SendBase) &#123;</span><br><span class="line">                SendBase=y</span><br><span class="line">                if (当前仍无任何应答报文) &#123;</span><br><span class="line">                    根据最近的 EstimatedRTT 和 DevRTT 设置超时间隔</span><br><span class="line">                    启动定时器                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123; </span><br><span class="line">                /* 该 ACK 包为一个对已经确认的报文段的冗余 ACK */</span><br><span class="line">                收到的序号为 y 的冗余 ACK 包的数量加 1</span><br><span class="line">                if(收到的序号为 y 的冗余 ACK 包数量 == 3) &#123;</span><br><span class="line">                    /* TCP 快速重传 */</span><br><span class="line">                    重新发送序号为 y 的报文段</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">&#125; </span><br><span class="line">/* end of loop forever */</span><br></pre></td></tr></table></figure>

<h2 id="流量控制">5.5. 流量控制</h2><h3 id="流量控制的简述">5.5.1. 流量控制的简述</h3><p>TCP 为应用程序提供了<code>拥塞控制(congestion control)</code>服务和<code>流量控制(flow control)</code>服务。<br>TCP 发送方由于 IP 网络的拥塞而被遏制, 这种形式的发送方的控制被称为<code>拥塞控制(congestion control)</code>。<br><code>流量控制(flow control)</code>是一种速度匹配服务, 使发送方的发送速率与接收方的读取速率相匹配, 以消除发送方使接收方缓存溢出的可能性。</p>
<h3 id="流量控制的实现">5.5.2. 流量控制的实现</h3><p>TCP 通过让双方维护一个称为<code>接收窗口(receive window, rwnd)</code>的变量来提供流量控制, 这个值代表了在接收方中可用的缓存空间。</p>
<p>首先我们来看接收窗口值是如何得到的。<br>下图为对在接收方中的<code>接收窗口(rwnd)</code>和<code>接收缓存(RcvBuffer)</code>的描述。<br><img src="/images/computer-networking-a-top-down-approach-03/13.png" alt="接收窗口(rwnd)和接收缓存(RcvBuffer)"><br>接收方始终维护两个变量: <code>LastByteRcvd</code> 以及 <code>LastByteRead</code>, 分别代表接收方收到的最后一个字节的编号以及接收方从缓存中读出的最后一个字节的编号。两者的差值即为已经使用的缓存空间。<br>因此<code>接收窗口(rwnd)</code>可通过下式算出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 初始状态下 rwnd = RcvBuffer</span><br><span class="line">rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]</span><br></pre></td></tr></table></figure>

<p>接收方会把 rwnd 值放入它发给发送方的报文段的接收窗口字段中, 用于通知发送方在该连接的缓存中还有多少可用空间。</p>
<p>发送方始终维护两个变量: <code>LastByteSent</code> 以及 <code>LastByteAcked</code>, 分别代表已发送的最后一个字节的序号和已经确认的最后一个字节的序号。两者的差值即为已发送、但仍未确认的数据大小。<br>由于 TCP 不允许缓存溢出, 因此发送方必须在整个连接过程中都保证:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LastByteSent - LastByteAcked ≤ rwnd</span><br></pre></td></tr></table></figure>

<p>最后考虑一种特殊情况, 若接收方返回的 rwnd 为 0 时, 发送方的行为。<br>此时, 发送方会发送只有一字节数据的报文段, 直到确认报文中的 rwnd 值不为 0 为止。</p>
<h2 id="TCP-连接管理">5.6. TCP 连接管理</h2><h3 id="三次握手">5.6.1. 三次握手</h3><p><code>三次握手(three-way handshake)</code>过程如下:</p>
<ol>
<li>客户端向服务器发送一 <code>SYN 报文段(SYN segment)</code>, <strong>该报文段不包含数据。</strong>客户端会把随机选择的<code>初始序号(client_isn)</code>放在报文段的序号字段中。</li>
<li><strong>在收到 SYN 报文段后, 服务器会为该连接分配缓存及变量。</strong>之后服务器会返回 <code>SYNACK 报文段(SYNACK segment)</code>。该报文段 SYN 位被置为1, 确认号为 <code>client_isn + 1</code>, 同时服务器会随机选择<code>初始序号(server_isn)</code>, 放入报文段的序号字段中。<strong>此报文段仍然不包含数据。</strong></li>
<li><strong>在收到 SYNACK 报文段后, 客户端会为该连接分配缓存及变量。</strong>客户端会发送最后一个报文段来告知服务器连接已建立。在该报文段中, 首部的确认字段为 <code>server_isn + 1</code>。<strong>在该报文段中可以携带数据。</strong></li>
</ol>
<p>下图为三次握手的 TCP 状态变化以及模拟图。<br><img src="/images/computer-networking-a-top-down-approach-03/14.png" alt="三次握手的 TCP 状态变化"></p>
<p><img src="/images/computer-networking-a-top-down-approach-03/15.png" alt="三次握手的模拟图"></p>
<h3 id="四次挥手">5.6.2. 四次挥手</h3><p><code>四次挥手(four-way wave)</code>过程如下:</p>
<ol>
<li>客户端发送<code>终止报文段(FIN segment)</code>, 该报文段的 FIN 位被置为 1。</li>
<li>服务器向客户端发送一个该报文段的确认报文段。</li>
<li>服务器向客户端发送<code>终止报文段(FIN segment)</code>。</li>
<li><strong>客户端向服务器发送一个该报文段的确认报文段, 同时释放资源。服务器在收到确认后, 也释放资源。</strong></li>
</ol>
<p>下图为四次挥手的 TCP 状态变化以及模拟图。<br><img src="/images/computer-networking-a-top-down-approach-03/16.png" alt="四次挥手的 TCP 状态变化"></p>
<p><img src="/images/computer-networking-a-top-down-approach-03/17.png" alt="四次挥手的模拟图"></p>
<h1 id="拥塞控制原理">6. 拥塞控制原理</h1><h2 id="为什么需要拥塞控制">6.1. 为什么需要拥塞控制?</h2><p>一般来说, 网络拥塞是由于分组太多引起的。这种情况下, 路由器缓存会迅速被填满并发生丢包, 丢包又会引起重传, 而重传会进一步加剧网络压力, 引起更多的丢包。<br>因此, 我们需要一种机制, 用于在网络拥塞时遏制发送方, 缓解拥塞的情况。</p>
<h2 id="拥塞带来了哪些坏处">6.2. 拥塞带来了哪些坏处?</h2><ol>
<li>对一条特定的链路来说, 当分组的到达速率接近链路容量时, 分组经历巨大的排队时延。</li>
<li>发送方必须执行重传以补偿因为缓存溢出而丢失的分组。</li>
<li>发送方发送的重传分组会浪费有限的带宽, 降低分组接收效率。</li>
<li>当一个分组沿着一条路径被丢弃时, 所有上游路由器所做的、将该分组转发至当前路由器的工作都白费了。</li>
</ol>
<h2 id="拥塞控制方法">6.3. 拥塞控制方法</h2><p>我们可以通过网络层是否为运输层拥塞控制提供了显式帮助, 来将拥塞控制方法分为以下两种:</p>
<ol>
<li><strong>端到端拥塞控制。</strong>在端到端拥塞控制方法中, 网络层没有向运输层提供显式帮助。</li>
<li><strong>网络辅助的拥塞控制。</strong>在网络辅助的拥塞控制方法中, 路由器会向发送方提供关于网络中拥塞状态的信息。一般来说有两种方式。第一种是直接反馈, 路由器直接向发送方发送通知, 告知发送方自己已经拥塞了; 另一种方式更为普遍, 路由器会标记发送方流向接收方的分组, 接收方收到分组后, 便向发送方发送信息, 告知发送方网络已拥塞。</li>
</ol>
<h1 id="TCP-拥塞控制">7. TCP 拥塞控制</h1><p>在上一节中, 我们了解了为什么需要拥塞控制, 以及拥塞控制的两种方法。这一节我们来看看作为一种广泛应用的通信协议, TCP 是如何进行拥塞控制的。<br>从上一节中我们可以得知, 一般拥塞控制方法可以分为两类: 一类是端到端拥塞控制, 另一类是网络辅助的拥塞控制。<strong>由于 IP 层并不向端系统提供显式的网络拥塞反馈, 因此 TCP 必须使用端到端拥塞控制。</strong><br>那么便出现了三个问题:</p>
<ol>
<li>一个 TCP 发送方如何限制它向连接发送的流量?</li>
<li>一个 TCP 发送方如何感知从它到目的主机之间的网络拥塞情况?</li>
<li>一个 TCP 发送方如何确定它应当发送的速率?</li>
</ol>
<p>接下来我们便来一一回答这些问题。</p>
<h2 id="TCP-发送方如何限制它向连接发送的流量">7.1. TCP 发送方如何限制它向连接发送的流量?</h2><p>在前面我们了解到, TCP 连接的每一端都是由一个接收缓存、一个发送缓存和几个变量组成的。在发送方中, 为了实现拥塞控制, 还会额外维护一个变量, 即<code>拥塞窗口(congestion window, cwnd)</code>。通过这个变量来对发送方的发送速率进行限制。具体规则是: 在一个发送方中, 未被确认的数据量不会超过 <code>cwnd</code> 和 <code>rwnd</code> 的最小值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LastByteSent - LastByteAcked ≤ min&#123;cwnd, rwnd&#125;</span><br></pre></td></tr></table></figure>

<p>其中, <code>rwnd</code> 是接收窗口, 表示在接收方中可用的缓存空间。<br>为了理解这一点, 我们可以来考虑具有如下条件的一条连接: 接收缓存足够大, 接收窗口的限制可以忽略不计; 发送方总有数据要发送; 所有的包都被正确送达; 并且发送时延都可以忽略不计。<br>在这种条件下, <code>往返时间(RTT)</code>基本是固定的。在发送的起始阶段, 由于上述限制条件的存在, 发送方允许发送的字节数为 <code>cwnd</code>。因此, 发送方的发送速率为 <code>cwnd/RTT 字节/秒</code>。通过调节 <code>cwnd</code> 的值, 便能够调整发送方的发送速率。</p>
<h2 id="TCP-发送方如何感知从它到目的主机之间的网络拥塞情况">7.2. TCP 发送方如何感知从它到目的主机之间的网络拥塞情况?</h2><p>TCP 发送方通过丢包事件来感知网络是否处于拥塞状态。具体来说有两种情况: 丢包和冗余 ACK。<br>当两种情况中的任意一种出现时, TCP 发送方便知道网络中出现了拥塞。</p>
<h2 id="TCP-发送方如何确定它应当发送的速率">7.3. TCP 发送方如何确定它应当发送的速率?</h2><p>前面我们已经知道, TCP 发送方可以通过拥塞窗口来控制发送速率, 且可以通过丢包事件来感知网络的拥塞情况。下面的问题便是如何来选取合适的发送速率了。<br>如果 TCP 发送方发送过快, 则会堵塞网络。如果 TCP 发送方发送过慢, 则不能充分利用带宽。因此, 这需要一个不断动态改变速率的算法来对发送速率进行控制, 这个过程被称为<code>带宽探测(bandwidth probing)</code>。</p>
<p>简单来说, 带宽探测的过程如下:<br>首先, TCP 发送方会不断增大传输速率, 直到出现丢包现象为止。<br>之后从该速率向后退, 并再次开始增大传输速率, 直到再次出现丢包为止。不断重复上述过程。</p>
<p>在这个过程中, <strong>当对先前未确认的报文段的 ACK 包到达时, 就增大发送方的速率, 这一操作是通过增大拥塞窗口实现的。当丢包现象出现时, 就减小发送方的速率, 这一操作是通过减小拥塞窗口实现的。</strong><br>以上整个过程被称为<code>TCP 拥塞控制算法(TCP congestion control algorithm)</code>, 下面我们便来看看这个算法的细节。</p>
<h2 id="TCP-拥塞控制算法-TCP-congestion-control-algorithm">7.4. TCP 拥塞控制算法(TCP congestion control algorithm)</h2><p>该算法的标准化描述在<a href="https://tools.ietf.org/html/rfc5681" target="_blank" rel="noopener">RFC 5681</a>中。<br>总的来说, 该算法分为三个部分:</p>
<ol>
<li><code>慢启动(slow-start)</code></li>
<li><code>拥塞避免(congestion avoidance)</code></li>
<li><code>快速恢复(fast recovery)</code></li>
</ol>
<p>其中, <strong>慢启动和快速恢复是 TCP 的强制部分, 其区别在于对收到 ACK 后增加 cwnd 长度的方式。快速恢复属于推荐部分, 对 TCP 发送方来说并不是必需的。</strong></p>
<p><img src="/images/computer-networking-a-top-down-approach-03/18.png" alt="TCP 拥塞控制算法的 FSM 描述"></p>
<h3 id="慢启动-slow-start">7.4.1. 慢启动(slow-start)</h3><p>当一条 TCP 连接开始时, <code>cwnd</code> 的值通常设置为一个 MSS。<br>在<code>慢启动(slow-start)</code>阶段, <code>cwnd</code> 的值以 1 个 MSS 开始, 并且每当传输的报文段首次被确认时就增加 1 个 MSS。因此<strong>在此阶段, 每过一个 RTT, <code>cwnd</code> 将翻倍, 发送速率也将翻倍。</strong></p>
<p>那么问题来了, 什么时候应该结束慢启动阶段呢? 有三种情况会结束慢启动阶段:</p>
<ul>
<li>当出现超时事件时, 此时 TCP 发送方会将 <code>cwnd</code> 设为 1 个 MSS, 并将 <code>ssthresh</code> 设置为 <code>cwnd/2</code>。之后会重新开始慢启动阶段。</li>
<li>当检测到 3 个冗余 ACK 时, 会将 <code>ssthresh</code> 设置为 <code>cwnd/2</code>, 并将 <code>cwnd</code> 设为 <code>ssthresh + 3 * MSS</code>。之后会进入快速恢复状态。</li>
<li>当 <code>cwnd</code> 的值等于 <code>ssthresh</code> 时, 结束慢启动并转移到拥塞避免模式。</li>
</ul>
<h3 id="拥塞避免-congestion-avoidance">7.4.2. 拥塞避免(congestion avoidance)</h3><p>进入<code>拥塞避免(congestion avoidance)</code>阶段时, <code>cwnd</code> 的值为上次遇到拥塞时的 <code>cwnd</code> 值的一半, 即距离拥塞可能并不遥远! 因此再采指数级增加发送速率就不太稳妥了。<br>在此阶段, 我们采用较为保守的方法增加发送速率: <strong>每过一个 RTT, <code>cwnd</code> 只增加 1 个 MSS。</strong>具体方法是, 对于 TCP 发送方, 无论何时到达一个新确认, 就将 <code>cwnd</code> 的值增加 1 个 <code>MSS(MSS/cwnd)</code> 字节。</p>
<p>那么什么时候应该结束这种线性增长呢? 有两种情况:</p>
<ul>
<li>当出现超时事件时, 此时 TCP 发送方会将 <code>cwnd</code> 设为 1 个 MSS, 并将 <code>ssthresh</code> 设置为 <code>cwnd/2</code>。之后会进入慢启动阶段。</li>
<li>当检测到 3 个冗余 ACK 时, 会将 <code>ssthresh</code> 设置为 <code>cwnd/2</code>, 并将 <code>cwnd</code> 设为 <code>ssthresh + 3 * MSS</code>。之后会进入快速恢复状态。</li>
</ul>
<p>可以看到, <strong>拥塞避免阶段与慢启动阶段处理丢包的方式完全一致。</strong></p>
<h3 id="快速恢复-fast-recovery">7.4.3. 快速恢复(fast recovery)</h3><p><code>快速恢复(fast recovery)</code>阶段的目的在于尽可能快的重传缺失的报文段。<br>因此, 在这一阶段, 每次收到一个针对缺失报文段的冗余 ACK, <code>cwnd</code> 的值便会增加 1 个 MSS。</p>
<p>结束此阶段的方式也有两种:</p>
<ul>
<li>收到了新的 ACK, 表示之前的丢失的报文段已成功送达。此时会将 <code>cwnd</code> 设置为 <code>ssthresh</code>, 并进入拥塞避免阶段。</li>
<li>当出现超时事件时, 此时 TCP 发送方会将 <code>cwnd</code> 设为 1 个 MSS, 并将 <code>ssthresh</code> 设置为 <code>cwnd/2</code>。之后会进入慢启动阶段。<strong>这一处理与慢启动阶段和拥塞避免阶段完全一致。</strong></li>
</ul>
<h3 id="总结">7.4.4. 总结</h3><p>在深入了解 TCP 拥塞控制算法的细节后, 我们有必要来回顾一下全局。<br><strong>忽略一条连接开始时初始的慢启动阶段(此阶段通常非常短, 因为发送速率会以指数增长, 很快离开该阶段),</strong> 同时假定丢包由 3 个冗余 ACK 而不是超时指示, 则 TCP 拥塞控制的整个过程为:<br><strong>每个 RTT 内 <code>cwnd</code> 线性增加 1 MSS, 然后出现 3 个冗余 ACK 时 <code>cwnd</code> 减半。</strong></p>
<p><img src="/images/computer-networking-a-top-down-approach-03/19.jpg" alt="加性增、乘性减"></p>
<p>可以看到, 整个过程中, TCP 发送速率的增加总是线性的, 而降低总是减半, 在图表上表现为锯齿状。因此, TCP 拥塞控制常常被称为<code>加性增、乘性减(additive-increase, multiplicative-decrease, AIMD)</code>拥塞控制方式。</p>
<h2 id="TCP-吞吐量">7.5. TCP 吞吐量</h2><p>在得知 TCP 的锯齿状行为后, 自然需要考虑一个长期存活的 TCP 连接的平均吞吐量是多少。这里直接给出两个公式, 具体推导过程不再叙述。</p>
<p>在这里, 我们依然不考虑慢启动阶段。则有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一条连接的平均吞吐量 = (0.75 * W) / RTT</span><br></pre></td></tr></table></figure>

<p>其中, <code>W</code> 是出现丢包时的拥塞窗口长度, 单位为字节。</p>
<p>在考虑丢包率时, 则有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一条连接的平均吞吐量 = (1.22 * MSS) / (RTT * L^1/2)</span><br></pre></td></tr></table></figure>

<p>其中, <code>L</code> 为丢包率, <code>MSS</code> 为最大报文的长度。</p>
<h2 id="公平性">7.6. 公平性</h2><p>当某个链路上存在多条连接时, 在拥塞控制机制的作用下, 如果每条连接都得到相同份额的链路带宽, 则认为该拥塞控制机制是公平的。<br><strong>TCP 的拥塞控制机制是一种公平的机制。相同条件下, TCP 趋于在竞争的多条 TCP 连接之间, 提供对一段瓶颈链路带宽的平等分享。</strong></p>
<p>但在实际中, 情况就略有不同了。有很多种情况可能会破坏不同连接使用带宽的平衡性。<br>当多条连接共享一个共同的瓶颈链路时, 具有较小 RTT 的连接能够在链路空闲时更快地抢到可用带宽(即更快地扩大拥塞窗口), 因而将比那些具有较大 RTT 的连接享有更高的吞吐量。<br>另外, UDP 源也可能会压制 TCP 流量, 导致 TCP 连接的可用带宽减小。<br>最后一点, 如果一个应用同时打开了多条 TCP 连接, 则其会比其他应用占用更多的带宽。</p>
<h2 id="网络辅助拥塞控制-明确拥塞通告">7.7. 网络辅助拥塞控制: 明确拥塞通告</h2><p>近年来, 针对 IP 和 TCP 的扩展方案<a href="https://tools.ietf.org/html/rfc3168" target="_blank" rel="noopener">RFC 3168</a>已经提出并已经实现和部署。该方案允许网络明确向 TCP 发送方和接收方发出拥塞信号。这种形式的网络辅助拥塞控制称为<code>明确拥塞通告(explicit congestion notification, ECN)</code>。</p>
<p>在网络层, IP 数据报首部的服务类型字段中的两个比特被用于 ECN, 共有四种可能的值。<br>路由器使用其中一个 ECN 比特设置指示该路由器正在经历拥塞。拥有该拥塞标记的数据报被发送给目的主机, 再由目的主机通知发送主机。<strong>RFC 3168 推荐仅当拥塞持续不断存在时才设置 ECN 比特。</strong><br>发送主机使用另一个 ECN 比特设置, 通知路由器发送方和接收方是 ECN 使能的, 能够对 ECN 指示的网络拥塞情况作出反应。当发送主机收到具有 ECN 标记的数据报时, 会减半拥塞窗口, 就像处理丢失报文段时的快速重传阶段一样。</p>
<p>除了 TCP 以外, 其他运输层协议也可以利用网络层发送 ECN 信号。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/计算机网络/" rel="tag"># 计算机网络</a>
          
            <a href="/tags/TCP/" rel="tag"># TCP</a>
          
            <a href="/tags/UDP/" rel="tag"># UDP</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/17/react-components-elements-and-instances/" rel="next" title="React Components, Elements, and Instances">
                <i class="fa fa-chevron-left"></i> React Components, Elements, and Instances
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/18/computer-networking-a-top-down-approach-04/" rel="prev" title="计算机网络：自顶向下方法读书笔记（四）">
                计算机网络：自顶向下方法读书笔记（四） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Mett Li</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-text">1. 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#运输层的层级"><span class="nav-text">1.1. 运输层的层级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运输层提供的功能"><span class="nav-text">1.2. 运输层提供的功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运输层实现的位置"><span class="nav-text">1.3. 运输层实现的位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运输层与网络层的区别"><span class="nav-text">1.4. 运输层与网络层的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运输层分组的名称"><span class="nav-text">1.5. 运输层分组的名称</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多路复用与多路分解"><span class="nav-text">2. 多路复用与多路分解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#多路复用与多路分解的报文结构"><span class="nav-text">2.1. 多路复用与多路分解的报文结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无连接的多路复用和多路分解"><span class="nav-text">2.2. 无连接的多路复用和多路分解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有连接的多路复用和多路分解"><span class="nav-text">2.3. 有连接的多路复用和多路分解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#无连接运输：UDP"><span class="nav-text">3. 无连接运输：UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要使用-UDP"><span class="nav-text">3.1. 为什么要使用 UDP?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP-报文段结构"><span class="nav-text">3.2. UDP 报文段结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#可靠数据传输原理"><span class="nav-text">4. 可靠数据传输原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#构造可靠数据传输协议"><span class="nav-text">4.1. 构造可靠数据传输协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#经过完全可靠信道的可靠数据传输：rdt1-0"><span class="nav-text">4.1.1. 经过完全可靠信道的可靠数据传输：rdt1.0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#经过具有比特差错信道的可靠数据传输：rdt2-0"><span class="nav-text">4.1.2. 经过具有比特差错信道的可靠数据传输：rdt2.0</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自动重传请求（ABQ）协议"><span class="nav-text">4.1.2.1. 自动重传请求（ABQ）协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rdt2-0"><span class="nav-text">4.1.2.2. rdt2.0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rdt2-1"><span class="nav-text">4.1.2.3. rdt2.1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rdt2-2"><span class="nav-text">4.1.2.4. rdt2.2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#经过具有比特差错的丢包信道的可靠数据传输：rdt3-0"><span class="nav-text">4.1.3. 经过具有比特差错的丢包信道的可靠数据传输：rdt3.0</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流水线可靠数据传输协议"><span class="nav-text">4.2. 流水线可靠数据传输协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回退-N-步"><span class="nav-text">4.2.1. 回退 N 步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择重传"><span class="nav-text">4.2.2. 选择重传</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向连接的运输：TCP"><span class="nav-text">5. 面向连接的运输：TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-连接"><span class="nav-text">5.1. TCP 连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初步了解三次握手"><span class="nav-text">5.1.1. 初步了解三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建立连接后的客户端"><span class="nav-text">5.1.2. 建立连接后的客户端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP报文段结构"><span class="nav-text">5.2. TCP报文段结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-报文段中的序号和确认号"><span class="nav-text">5.2.1. TCP 报文段中的序号和确认号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#往返时间的估计与超时"><span class="nav-text">5.3. 往返时间的估计与超时</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可靠数据传输"><span class="nav-text">5.4. 可靠数据传输</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流量控制"><span class="nav-text">5.5. 流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#流量控制的简述"><span class="nav-text">5.5.1. 流量控制的简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流量控制的实现"><span class="nav-text">5.5.2. 流量控制的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-连接管理"><span class="nav-text">5.6. TCP 连接管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#三次握手"><span class="nav-text">5.6.1. 三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四次挥手"><span class="nav-text">5.6.2. 四次挥手</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#拥塞控制原理"><span class="nav-text">6. 拥塞控制原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么需要拥塞控制"><span class="nav-text">6.1. 为什么需要拥塞控制?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拥塞带来了哪些坏处"><span class="nav-text">6.2. 拥塞带来了哪些坏处?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拥塞控制方法"><span class="nav-text">6.3. 拥塞控制方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP-拥塞控制"><span class="nav-text">7. TCP 拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-发送方如何限制它向连接发送的流量"><span class="nav-text">7.1. TCP 发送方如何限制它向连接发送的流量?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-发送方如何感知从它到目的主机之间的网络拥塞情况"><span class="nav-text">7.2. TCP 发送方如何感知从它到目的主机之间的网络拥塞情况?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-发送方如何确定它应当发送的速率"><span class="nav-text">7.3. TCP 发送方如何确定它应当发送的速率?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-拥塞控制算法-TCP-congestion-control-algorithm"><span class="nav-text">7.4. TCP 拥塞控制算法(TCP congestion control algorithm)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#慢启动-slow-start"><span class="nav-text">7.4.1. 慢启动(slow-start)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拥塞避免-congestion-avoidance"><span class="nav-text">7.4.2. 拥塞避免(congestion avoidance)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速恢复-fast-recovery"><span class="nav-text">7.4.3. 快速恢复(fast recovery)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-text">7.4.4. 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-吞吐量"><span class="nav-text">7.5. TCP 吞吐量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#公平性"><span class="nav-text">7.6. 公平性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络辅助拥塞控制-明确拥塞通告"><span class="nav-text">7.7. 网络辅助拥塞控制: 明确拥塞通告</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mett Li</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
